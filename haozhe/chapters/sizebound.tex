\chapter{Size Bounds of Join Queries}

% motivation of estimation
Join queries are critical in relational database management systems and comparably very expensive. The cost of executing a query with multiple joins depends dramatically on the query evaluation plan generated by the query optimiser and the join order is one of the most important determinants of the query evaluation cost. The query optimiser uses the estimation of join result size to choose the join order to minimises the lowest cost. So, the estimation of join result size is in a query is an important problem in relational database management systems []. This chapter introduces the researches related to the size bounds of the join results. 

Given a database and a query, we can exploit information that are useful for the join size estimation without performing the join. There are two types of information from query and database. The first one is the structural information including conditional independence and the width of the query and the second one is the cardinality information which focus on the quantitative aspects of the query and database. Different from the structural information, it considers the input relation sizes and uses sizes in the estimation. The commercial RDBMSs seem to place little emphasis on the structural property of the query and tremendous emphasis on the cardinality side of join processing. 

In this chapter, we introduce the size bounds of the join query result for both listing representations and factorised representations. 


\section{Listing Representations}

Consider the path query $Q = R(A,B)S(B,C)T(C,D)$, assume all relations have size $N$, the final join result must be a subset of the intermediate result $RS = R(A,B)T(C,D)$ because all the attributes are covered by these two relations and all tuples appear in the final result are also in $RS$. The continuing join of $S(B,C)$ can only filter out tuples from $R(A,B)T(C,D)$ and not add new tuples. So, we say the size of $Q$ is bounded by the size of $R(A,B)T(C,D)$ which is $N^2$. The generalisation of this idea is that the join query $Q$ is a subset of an intermediate join result which covers all attributes in the schema of $Q$ so the size of the join result is bounded by the size of those intermediate results. 

\subsection{Edge Covers and Independent Sets}

Assume there is a given query $Q$ and its hypergraph $\calH=(\calV, \calE)$. An edge cover of $\calH$ is the set $C \subseteq \calE$ such that each node in $\calV$ is covered by at least one hyperedge in $C$. The edge cover number $\rho(Q)$ of $Q$ is the minimum size of all possible edge covers. Assume all relations have the same size $N$, the upper bound of the join result size is $N^{\rho(Q)}$.

The lower bound of the join result depends on the maximum independent sets of $\calH$ 
where an independent set of a query hypergraph is the set of $I \subseteq \calV$ such that no two of which are in the same hyperedge and the maximum independent set is an valid independent set with the maximum size. Since the attributes in the maximum independent set are independent, they do not have constraint on the values of the other attributes so the size of the Cartesian product of the values of these attributes should be the lower bound of the size of the query. Since the number of values for each attribute is $N$, the lower bound is $N^{m}$ where $m$ is the size of the maximum independent set. Then, we have the size bounds for the join result which is 
$$N^m  \leq |Q| \leq N^{\rho(Q)}$$
However, the value of $m$ and $\rho(Q)$ does not necessarily meet. In other words, there exists gap between the upper bound and the lower bound. To make the estimation more precisely, we need the Fractional Edge Cover Number.

\subsection{Fractional Edge Cover Number}

Intuitively, fractional edge cover number, $\rho^*(Q)$ is a more relaxing variant of $\rho(Q)$ in that each node in $\calV$ does not have to be covered entirely by a single hyperedge. It is accepted the node is covered by multiple hyperedges fractionally. Formally, hyperedges in $\calE$ are assigned weight, and the fractional edge cover number of the query is the result of the linear programming:




% Relaxing the constraints that we have to cover an attribute using complete relations
% In other words, cover an attributes using the fractional of a relation
% The definition of rho start (linear programming)
% the edge covers is the special case that only use {0,1}

% intuition of why it is the upper bound
% Fractional edge cover
% Fractional independent set
% duality of linear programming? (important)











% relaxing the constriants of integer version
% cover a variable using fractional of a relation

% Formally Definition of rhostar
% the edge covers is the special case that only use {0,1}

% intuition of why it is the upperbound
% Fractional edge cover
% Fractional independent set

% duality of linear programming? (important)

% this is the size in worst case! both upper bound and lower bound

% Examples


% for the cardinality constraints concerns
% - relations have different sizes
% - small-size projections of relations may be added to the join query (another hyperedge)

% adapt the linear programming to consider the relation sizes

% if a relation has a very small size, to increase that relation to cover more variables 


\subsection{AGM Bound}

\section{Factorised Representations}

% single values appear over over again
% block of values appear over over again

% relational algebra
% singletons
% relational product, union

% distributivity of product over union and their commutativity (where factorisation comes from)
% groundings of variable orders

% smaller than listing representation
% - some singletons are not repeated
% - fact Cartesian product is not materialised more symbolically

% further compression using caching (can be exponentially)

% \textbf{size bounds}

% how much space dose factorisation save over the listing representation
% the size bounds for join results
% - AGM08
% - OZ12 s(Q)
% - OZ15 fhtw
% with log modulo pre-processing
% the comparison figure  

% fit in the memory
% improve on both time and space complexity
% enumeration with constant delay:
% - efficient aggregates

% % ---------
% bounds are asymptotically tight
% but not database optimal

% Factorisation width s(Q): intuition
% similar with the edge cover number, explain why factorisation width is the bound of the factorised representations

% We calculate the size of the representation by computing the number of singletons for each attribute and sum them together, i.e. ... . 
% For the factorisation The information stored in C is independent on the attributes in the other branches or its descendents. So:
% - the number of values for a specific variable is dictated by the number of valid tuples of values for its ancestors in variable order
% - size of factorisation = sum of sizes of results of subqueries along paths

% consider your query into sub-queries that only look into root-to-leaf paths
% // Compare it with the rho*, rho* looks for the size of the whole graph, s(Q) looks for only a path in the graph
% the size of singletons of an attribute does not depend on all attributes in the graph (rho*), it only depends on the root-to-leaf paths
% rho* can be seen as a s(Q) that consider the dependency of the whole graph

% apply the fractional edge cover number on paths!

% why fhtw factorised representation with caching can be better
% F only depends on E and does not depend on A, so with the same E, the F is always the same and they are cached so only appears once in the factorised representation. 



% the connection between fhtw and s\^(Q)





\section{Covers}

% motivation: difiicult to integrate them into relational data systems

% get all the benefits of the factorisation but store them in the relation (fhtw(Q))
% choose some of the tuples from the relation, then they can represent the whole relation

% % --------------------------------
% How to compute the cover
% - hyperedges of the data rather than query
% - minimal hyperedge covers will tell everything we need to know
% - store the nodes and remember everything pairs everything





% how to compute the cover
% how to recover the listing representation from a cover (constant delay enumeration)


